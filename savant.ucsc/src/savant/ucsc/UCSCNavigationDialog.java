/*
 *    Copyright 2011 University of Toronto
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package savant.ucsc;

import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Window;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JDialog;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import savant.api.util.DialogUtils;
import savant.sql.ColumnMapping;
import savant.sql.Database;
import savant.sql.MappingDialog;
import savant.sql.MappingDialog.FormatDef;
import savant.sql.MappingPanel;
import savant.sql.SQLConstants;
import savant.sql.SQLWorker;
import savant.sql.Table;


/**
 * UCSC-specific dialog for selecting the desired table.
 *
 * @author tarkvara
 */
public class UCSCNavigationDialog extends JDialog implements SQLConstants {
    private static final Log LOG = LogFactory.getLog(UCSCNavigationDialog.class);

    private final UCSCDataSourcePlugin plugin;
    private MappingPanel mappingPanel;
    private ColumnMapping knownMapping;

    private Map<String, ArrayList<String>> cladeGenomeMap = new HashMap<String, ArrayList<String>>();
    private Map<String, String> genomeDBMap = new HashMap<String, String>();
    private Map<String, ArrayList<TrackDef>> groupTrackMap = new HashMap<String, ArrayList<TrackDef>>();

    private Database genomeDB = null;
    private Table trackTable = null;

    /**
     * Dialog which lets the user navigate through the UCSC hierarchy and select
     * the table they want.
     *
     * @param parent can be null
     */
    public UCSCNavigationDialog(Window parent, UCSCDataSourcePlugin plugin) throws SQLException {
        super(parent, ModalityType.APPLICATION_MODAL);
        this.plugin = plugin;
        initComponents();

        mappingPanel = new MappingPanel();
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 1;
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.insets = new Insets(8, 8, 8, 8);
        add(mappingPanel, gbc);

        formatCombo.setModel(MappingDialog.FORMAT_COMBO_MODEL);
        populateCladeCombo();
        pack();
        setLocationRelativeTo(parent);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        okButton = new javax.swing.JButton();
        cancelButton = new javax.swing.JButton();
        javax.swing.JPanel navigationPanel = new javax.swing.JPanel();
        javax.swing.JLabel cladeLabel = new javax.swing.JLabel();
        cladeCombo = new javax.swing.JComboBox();
        javax.swing.JLabel genomeLabel = new javax.swing.JLabel();
        genomeCombo = new javax.swing.JComboBox();
        javax.swing.JLabel groupLabel = new javax.swing.JLabel();
        groupCombo = new javax.swing.JComboBox();
        javax.swing.JLabel trackLabel = new javax.swing.JLabel();
        trackCombo = new javax.swing.JComboBox();
        javax.swing.JLabel formatLabelLabel = new javax.swing.JLabel();
        formatLabel = new javax.swing.JLabel();
        formatCombo = new javax.swing.JComboBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        getContentPane().setLayout(new java.awt.GridBagLayout());

        okButton.setText("OK");
        okButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        getContentPane().add(okButton, gridBagConstraints);

        cancelButton.setText("Cancel");
        cancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        getContentPane().add(cancelButton, gridBagConstraints);

        navigationPanel.setLayout(new java.awt.GridBagLayout());

        cladeLabel.setText("Clade:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        navigationPanel.add(cladeLabel, gridBagConstraints);

        cladeCombo.setMaximumSize(new java.awt.Dimension(300, 32767));
        cladeCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cladeComboActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        navigationPanel.add(cladeCombo, gridBagConstraints);

        genomeLabel.setText("Genome:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        navigationPanel.add(genomeLabel, gridBagConstraints);

        genomeCombo.setMaximumSize(new java.awt.Dimension(300, 32767));
        genomeCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                genomeComboActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        navigationPanel.add(genomeCombo, gridBagConstraints);

        groupLabel.setText("Group:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        navigationPanel.add(groupLabel, gridBagConstraints);

        groupCombo.setMaximumRowCount(9);
        groupCombo.setMaximumSize(new java.awt.Dimension(300, 32767));
        groupCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                groupComboActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        navigationPanel.add(groupCombo, gridBagConstraints);

        trackLabel.setText("Track:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        navigationPanel.add(trackLabel, gridBagConstraints);

        trackCombo.setMaximumSize(new java.awt.Dimension(300, 32767));
        trackCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                trackComboActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        navigationPanel.add(trackCombo, gridBagConstraints);

        formatLabelLabel.setText("Format:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        navigationPanel.add(formatLabelLabel, gridBagConstraints);

        formatLabel.setText("BED");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        navigationPanel.add(formatLabel, gridBagConstraints);

        formatCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                formatComboActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        navigationPanel.add(formatCombo, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        getContentPane().add(navigationPanel, gridBagConstraints);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed
        ColumnMapping mapping = mappingPanel.getMapping();
        if (mapping != null) {
            plugin.setTable(trackTable);
            plugin.setMapping(mapping);
            setVisible(false);
        }
}//GEN-LAST:event_okButtonActionPerformed

    private void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelButtonActionPerformed
        if (genomeDB != null) {
            genomeDB.closeConnection();
        }
        setVisible(false);
}//GEN-LAST:event_cancelButtonActionPerformed

    private void cladeComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cladeComboActionPerformed
        populateGenomeCombo();
    }//GEN-LAST:event_cladeComboActionPerformed

    private void genomeComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_genomeComboActionPerformed
        populateGroupCombo();
    }//GEN-LAST:event_genomeComboActionPerformed

    private void groupComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_groupComboActionPerformed
        populateTrackCombo();
    }//GEN-LAST:event_groupComboActionPerformed

    private void trackComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_trackComboActionPerformed
        TrackDef track = (TrackDef)trackCombo.getSelectedItem();
        knownMapping = UCSCDataSourcePlugin.getKnownMapping(track.type);
        trackTable = new Table(track.table, genomeDB);
        formatLabel.setText(track.type);
        if (knownMapping != null) {
            switch (knownMapping.format) {
                case INTERVAL_BED:
                    formatCombo.setSelectedIndex(0);
                    break;
                case INTERVAL_GENERIC:
                    formatCombo.setSelectedIndex(1);
                    break;
                case CONTINUOUS_GENERIC:
                    formatCombo.setSelectedIndex(2);
                    break;
            }
        }
    }//GEN-LAST:event_trackComboActionPerformed

    private void formatComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_formatComboActionPerformed
        mappingPanel.setFormat(((FormatDef)formatCombo.getSelectedItem()).format);
        try {
            mappingPanel.populate(trackTable.getColumns(), knownMapping);
        } catch (SQLException sqlx) {
            LOG.error(sqlx);
            DialogUtils.displayException("SQL Error", "Unable to get list of columns.", sqlx);
        }
    }//GEN-LAST:event_formatComboActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton cancelButton;
    private javax.swing.JComboBox cladeCombo;
    private javax.swing.JComboBox formatCombo;
    private javax.swing.JLabel formatLabel;
    private javax.swing.JComboBox genomeCombo;
    private javax.swing.JComboBox groupCombo;
    private javax.swing.JButton okButton;
    private javax.swing.JComboBox trackCombo;
    // End of variables declaration//GEN-END:variables

    private void populateCladeCombo() throws SQLException {
        new SQLWorker(DialogUtils.getMainWindow(), "Fetching track list...", "Unable to fetch track list from UCSC.") {
            String selectedClade = null;

            @Override
            public void doInBackground() throws SQLException {
                String selectedDB = null;
                if (plugin.getTable() != null) {
                    selectedDB = plugin.getDatabase().getName();
                }
                ResultSet rs = plugin.hgcentral.executeQuery("SELECT DISTINCT name,description,genome,clade FROM dbDb NATURAL JOIN genomeClade WHERE active='1' ORDER by clade,orderKey");
                String lastClade = null;
                ArrayList<String> cladeGenomes = new ArrayList<String>();
                while (rs.next()) {
                    String genome = rs.getString("genome") + " - " + rs.getString("description");

                    // In the database, clades are stored in lowercase, and Nematodes are called worms.
                    String clade = rs.getString("clade");
                    if (clade.equals("worm")) {
                        clade = "Nematode";
                    } else {
                        clade = Character.toUpperCase(clade.charAt(0)) + clade.substring(1);
                    }
                    String dbName = rs.getString("name");
                    if (dbName.equals(selectedDB)) {
                        selectedClade = clade;
                    }

                    if (!clade.equals(lastClade)) {
                        if (lastClade != null) {
                            cladeGenomeMap.put(lastClade, cladeGenomes);
                            cladeGenomes = new ArrayList<String>();
                        }
                        lastClade = clade;
                    }
                    genomeDBMap.put(genome, dbName);
                    cladeGenomes.add(genome);
                }
                cladeGenomeMap.put(lastClade, cladeGenomes);
            }

            @Override
            public void done() throws SQLException {
                cladeCombo.setModel(new DefaultComboBoxModel(new String[] { "Mammal", "Vertebrate", "Deuterostome", "Insect", "Nematode", "Other" }));
                if (selectedClade != null) {
                    cladeCombo.setSelectedItem(selectedClade);
                } else {
                    cladeCombo.setSelectedIndex(0);
                }
            }
        };
    }

    private void populateGenomeCombo() {
        String clade = (String)cladeCombo.getSelectedItem();
        genomeCombo.setModel(new DefaultComboBoxModel(cladeGenomeMap.get(clade).toArray()));
        genomeCombo.setSelectedIndex(0);
    }

    private void populateGroupCombo() {
        final String genome = (String)genomeCombo.getSelectedItem();
        new SQLWorker(this, String.format("Fetching tables for %s...", genome), "Unable to fetch table list from UCSC.") {
            ArrayList<String> groups;

            @Override
            public void doInBackground() throws SQLException {
                if (genomeDB != null) {
                    genomeDB.closeConnection();
                }
                genomeDB = plugin.getDatabase(genomeDBMap.get(genome));

                List<Table> tables = genomeDB.getTables();
                groupTrackMap.clear();
                groups = new ArrayList<String>();
    //            ResultSet rs = genomeDB.executeQuery("SELECT label,tableName,shortLabel,type FROM trackDb,grp WHERE trackDb.grp = grp.name AND trackDb.type LIKE 'bed%%' ORDER BY trackDb.grp,trackDb.priority");
                ResultSet rs = genomeDB.executeQuery("SELECT label,tableName,shortLabel,type FROM trackDb,grp WHERE trackDb.grp = grp.name ORDER BY grp.priority,trackDb.priority,trackDb.tableName");
                String lastGroup = null;
                ArrayList<TrackDef> groupTracks = new ArrayList<TrackDef>();
                while (rs.next()) {
                    String track = rs.getString("tableName");
                    String group = rs.getString("label");
                    String label = rs.getString("shortLabel");
                    String type = rs.getString("type");
                    TrackDef def = null;
                    String error = null;
                    for (Table t: tables) {
                        if (t.getName().equals(track)) {
                            if (UCSCDataSourcePlugin.getKnownMapping(type) != null) {
                                def = new TrackDef(track, label, type);
                            } else {
                                error = "Unmapped track type " + type + " for table " + track;
                            }
                            break;
                        }
                    }

                    if (def != null) {
                        if (!group.equals(lastGroup)) {
                            if (lastGroup != null && groupTracks.size() > 0) {
                                groupTrackMap.put(lastGroup, groupTracks);
                                groupTracks = new ArrayList<TrackDef>();
                            }
                            groups.add(group);
                            lastGroup = group;
                        }
                        groupTracks.add(def);
                    } else {
                        if (!type.startsWith("bigWig") && !type.startsWith("wig") && !type.equals("bam") && !type.startsWith("bigBed")) {
                            if (error == null) {
                                error = "Unknown track " + track + " not found in table list for " + genomeDB;
                            }
                            LOG.info(error);
                        }
                    }
                }
                if (groupTracks.size() > 0) {
                    groupTrackMap.put(lastGroup, groupTracks);
                }
            }

            @Override
            public void done() {
                groupCombo.setModel(new DefaultComboBoxModel(groups.toArray()));
                groupCombo.setSelectedIndex(0);
            }
        };
    }

    private void populateTrackCombo() {
        String group = (String)groupCombo.getSelectedItem();
        trackCombo.setModel(new DefaultComboBoxModel(groupTrackMap.get(group).toArray()));
        trackCombo.setSelectedIndex(0);
    }

    class TrackDef {
        String table;
        String label;
        String type;

        TrackDef(String table, String label, String type) {
            this.table = table;
            this.label = label;
            this.type = type;
        }

        @Override
        public String toString() {
            return table + " - " + label;
        }
    }

}
