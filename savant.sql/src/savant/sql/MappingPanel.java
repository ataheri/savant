/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * MappingPanel.java
 *
 * Created on Feb 23, 2011, 5:51:36 PM
 */

package savant.sql;

import java.sql.Types;
import javax.swing.JComboBox;
import javax.swing.JPanel;

import savant.file.DataFormat;

/**
 *
 * @author tarkvara
 */
public class MappingPanel extends JPanel implements SQLConstants {
    private DataFormat format;
    private JComboBox valueCombo;

    /** Creates new form MappingPanel */
    public MappingPanel() {
        initComponents();
        valueCombo = nameCombo;     // They're the same widget, but code makes more sense this way.
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        javax.swing.JLabel chromLabel = new javax.swing.JLabel();
        chromCombo = new javax.swing.JComboBox();
        javax.swing.JLabel startLabel = new javax.swing.JLabel();
        startCombo = new javax.swing.JComboBox();
        javax.swing.JLabel endLabel = new javax.swing.JLabel();
        endCombo = new javax.swing.JComboBox();
        nameLabel = new javax.swing.JLabel();
        nameCombo = new javax.swing.JComboBox();
        scoreLabel = new javax.swing.JLabel();
        scoreCombo = new javax.swing.JComboBox();
        strandLabel = new javax.swing.JLabel();
        strandCombo = new javax.swing.JComboBox();
        thickStartLabel = new javax.swing.JLabel();
        thickStartCombo = new javax.swing.JComboBox();
        thickEndLabel = new javax.swing.JLabel();
        thickEndCombo = new javax.swing.JComboBox();
        itemRGBLabel = new javax.swing.JLabel();
        itemRGBCombo = new javax.swing.JComboBox();
        blockStartsLabel = new javax.swing.JLabel();
        blockStartsCombo = new javax.swing.JComboBox();
        blockEndsLabel = new javax.swing.JLabel();
        blockEndsCombo = new javax.swing.JComboBox();
        blockSizesLabel = new javax.swing.JLabel();
        blockSizesCombo = new javax.swing.JComboBox();
        jPanel1 = new javax.swing.JPanel();

        setBorder(javax.swing.BorderFactory.createTitledBorder("Field Mappings"));
        setMinimumSize(new java.awt.Dimension(400, 412));
        setPreferredSize(new java.awt.Dimension(400, 412));
        setLayout(new java.awt.GridBagLayout());

        chromLabel.setText("Chromosome:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(chromLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(chromCombo, gridBagConstraints);

        startLabel.setText("Start:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(startLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(startCombo, gridBagConstraints);

        endLabel.setText("End:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(endLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(endCombo, gridBagConstraints);

        nameLabel.setText("Name:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(nameLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        add(nameCombo, gridBagConstraints);

        scoreLabel.setText("Score:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(scoreLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(scoreCombo, gridBagConstraints);

        strandLabel.setText("Strand:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(strandLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(strandCombo, gridBagConstraints);

        thickStartLabel.setText("Thick Start:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(thickStartLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(thickStartCombo, gridBagConstraints);

        thickEndLabel.setText("Thick End:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(thickEndLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(thickEndCombo, gridBagConstraints);

        itemRGBLabel.setText("Item RGB:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(itemRGBLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(itemRGBCombo, gridBagConstraints);

        blockStartsLabel.setText("Block Starts:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(blockStartsLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(blockStartsCombo, gridBagConstraints);

        blockEndsLabel.setText("Block Ends:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(blockEndsLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(blockEndsCombo, gridBagConstraints);

        blockSizesLabel.setText("Block Sizes:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(blockSizesLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(blockSizesCombo, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.weighty = 1.0;
        add(jPanel1, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox blockEndsCombo;
    private javax.swing.JLabel blockEndsLabel;
    private javax.swing.JComboBox blockSizesCombo;
    private javax.swing.JLabel blockSizesLabel;
    private javax.swing.JComboBox blockStartsCombo;
    private javax.swing.JLabel blockStartsLabel;
    private javax.swing.JComboBox chromCombo;
    private javax.swing.JComboBox endCombo;
    private javax.swing.JComboBox itemRGBCombo;
    private javax.swing.JLabel itemRGBLabel;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JComboBox nameCombo;
    private javax.swing.JLabel nameLabel;
    private javax.swing.JComboBox scoreCombo;
    private javax.swing.JLabel scoreLabel;
    private javax.swing.JComboBox startCombo;
    private javax.swing.JComboBox strandCombo;
    private javax.swing.JLabel strandLabel;
    private javax.swing.JComboBox thickEndCombo;
    private javax.swing.JLabel thickEndLabel;
    private javax.swing.JComboBox thickStartCombo;
    private javax.swing.JLabel thickStartLabel;
    // End of variables declaration//GEN-END:variables

    public void setFormat(DataFormat format) {
        this.format = format;
        nameLabel.setText(format == DataFormat.CONTINUOUS_GENERIC ? "Value:" : "Name:");
        switch (format) {
            case INTERVAL_BED:
                scoreLabel.setVisible(true);
                scoreCombo.setVisible(true);
                strandLabel.setVisible(true);
                strandCombo.setVisible(true);
                thickStartLabel.setVisible(true);
                thickStartCombo.setVisible(true);
                thickEndLabel.setVisible(true);
                thickEndCombo.setVisible(true);
                itemRGBLabel.setVisible(true);
                itemRGBCombo.setVisible(true);
                blockStartsLabel.setVisible(true);
                blockStartsCombo.setVisible(true);
                blockEndsLabel.setVisible(true);
                blockEndsCombo.setVisible(true);
                blockSizesLabel.setVisible(true);
                blockSizesCombo.setVisible(true);
                break;
            default:
                scoreLabel.setVisible(false);
                scoreCombo.setVisible(false);
                strandLabel.setVisible(false);
                strandCombo.setVisible(false);
                thickStartLabel.setVisible(false);
                thickStartCombo.setVisible(false);
                thickEndLabel.setVisible(false);
                thickEndCombo.setVisible(false);
                itemRGBLabel.setVisible(false);
                itemRGBCombo.setVisible(false);
                blockStartsLabel.setVisible(false);
                blockStartsCombo.setVisible(false);
                blockEndsLabel.setVisible(false);
                blockEndsCombo.setVisible(false);
                blockSizesLabel.setVisible(false);
                blockSizesCombo.setVisible(false);
                break;
        }
    }

    public void populate(Column[] columns, ColumnMapping mapping) {
        populateFieldCombo(chromCombo, columns, Types.CHAR, mapping.chrom);
        populateFieldCombo(startCombo, columns, Types.INTEGER, mapping.start);
        populateFieldCombo(endCombo, columns, Types.INTEGER, mapping.end);
        switch (format) {
            case CONTINUOUS_GENERIC:
                populateFieldCombo(nameCombo, columns, Types.REAL, mapping.value);
                break;
            case INTERVAL_GENERIC:
                populateFieldCombo(nameCombo, columns, Types.CHAR, mapping.name);
                break;
            case INTERVAL_BED:
                populateFieldCombo(nameCombo, columns, Types.CHAR, mapping.name);
                populateFieldCombo(scoreCombo, columns, Types.REAL, mapping.score);
                populateFieldCombo(strandCombo, columns, Types.CHAR, mapping.strand);
                populateFieldCombo(thickStartCombo, columns, Types.INTEGER, mapping.thickStart);
                populateFieldCombo(thickEndCombo, columns, Types.INTEGER, mapping.thickEnd);
                populateFieldCombo(itemRGBCombo, columns, Types.INTEGER, mapping.itemRGB);
                populateFieldCombo(blockStartsCombo, columns, Types.BLOB, mapping.blockStarts);
                populateFieldCombo(blockEndsCombo, columns, Types.BLOB, mapping.blockEnds);
                populateFieldCombo(blockSizesCombo, columns, Types.BLOB, mapping.blockSizes);
                break;
        }
    }

    /**
     * Populate the field combo columns of the appropriate type.
     *
     * @param combo combo-box to be populated
     * @param columns array of column definitions from the table
     * @param desiredType one of Types.CHAR, Types.INTEGER, Types.REAL, or Types.BLOB to indicate the general type of data desired
     * @param mappedName name of column we think this combo should be mapped to
     */
    private void populateFieldCombo(JComboBox combo, Column[] columns, int desiredType, String mappedName) {
        combo.removeAllItems();

        // If we have mappings defined for this field, use it to determine the selected item.
        Column mappedCol = null;

        // Some columns allow the user to leave the column unused.
        if (combo != chromCombo && chromCombo != startCombo && chromCombo != endCombo) {
            combo.addItem(NO_COLUMN);
        }

        for (Column c : columns) {
            boolean include = false;
            switch (c.type) {
                case Types.CHAR:
                case Types.LONGNVARCHAR:
                case Types.NCHAR:
                case Types.NVARCHAR:
                case Types.VARCHAR:
                    include = desiredType == Types.CHAR;
                    break;
                case Types.BIGINT:
                case Types.INTEGER:
                case Types.SMALLINT:
                case Types.TINYINT:
                    include = desiredType == Types.INTEGER || desiredType == Types.REAL;
                    break;
                case Types.DECIMAL:
                case Types.DOUBLE:
                case Types.FLOAT:
                case Types.NUMERIC:
                case Types.REAL:
                    include = desiredType == Types.REAL;
                    break;
                case Types.BINARY:
                case Types.BLOB:
                case Types.LONGVARBINARY:
                case Types.VARBINARY:
                    include = desiredType == Types.BLOB;
                    break;
            }
            if (include) {
                combo.addItem(c);
                if (c.name.equals(mappedName)) {
                    mappedCol = c;
                }
            }
        }
        if (mappedCol != null) {
            combo.setSelectedItem(mappedCol);
        }
    }

    public ColumnMapping getMapping() {
        switch (format) {
            case CONTINUOUS_GENERIC:
                return ColumnMapping.getContinuousMapping(chromCombo.getSelectedItem().toString(),
                        startCombo.getSelectedItem().toString(),
                        endCombo.getSelectedItem().toString(),
                        valueCombo.getSelectedItem().toString());
            case INTERVAL_GENERIC:
                return ColumnMapping.getIntervalMapping(chromCombo.getSelectedItem().toString(),
                        startCombo.getSelectedItem().toString(),
                        endCombo.getSelectedItem().toString(),
                        nameCombo.getSelectedItem().toString());
            case INTERVAL_BED:
                return ColumnMapping.getBEDMapping(chromCombo.getSelectedItem().toString(),
                                                   startCombo.getSelectedItem().toString(),
                                                   endCombo.getSelectedItem().toString(),
                                                   nameCombo.getSelectedItem().toString(),
                                                   scoreCombo.getSelectedItem().toString(),
                                                   strandCombo.getSelectedItem().toString(),
                                                   thickStartCombo.getSelectedItem().toString(),
                                                   thickEndCombo.getSelectedItem().toString(),
                                                   itemRGBCombo.getSelectedItem().toString(),
                                                   blockStartsCombo.getSelectedItem().toString(),
                                                   blockEndsCombo.getSelectedItem().toString(),
                                                   blockSizesCombo.getSelectedItem().toString());
            default:
                return null;
        }
    }
}
