/**
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 */
package savant.sql;

import java.sql.Types;
import javax.swing.JComboBox;
import javax.swing.JPanel;


/**
 * Shared by MappingDialog and UCSCNavigationDialog, to set up specific mappings between
 * Savant fields and database columns.
 *
 * @author tarkvara
 */
public class MappingPanel extends JPanel implements SQLConstants {
    private MappingFormat format;
    private JComboBox valueCombo;
    private JComboBox spanCombo;
    private JComboBox countCombo;
    private JComboBox offsetCombo;
    private JComboBox fileCombo;
    private JComboBox lowerLimitCombo;
    private JComboBox dataRangeCombo;
    private JComboBox pathCombo;

    /** Creates new form MappingPanel */
    public MappingPanel() {
        initComponents();

        // In Designer, we lay out all the combo-boxes as for a BED file (because
        // it has the most columns.  However, to make the code in the file easier to
        // read, we give the widgets aliases
        valueCombo = nameCombo;
        spanCombo = nameCombo;
        countCombo = scoreCombo;
        offsetCombo = strandCombo;
        fileCombo = thickStartCombo;
        lowerLimitCombo = thickEndCombo;
        dataRangeCombo = itemRGBCombo;
        pathCombo = chromCombo;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        chromLabel = new javax.swing.JLabel();
        chromCombo = new javax.swing.JComboBox();
        startLabel = new javax.swing.JLabel();
        startCombo = new javax.swing.JComboBox();
        endLabel = new javax.swing.JLabel();
        endCombo = new javax.swing.JComboBox();
        nameLabel = new javax.swing.JLabel();
        nameCombo = new javax.swing.JComboBox();
        scoreLabel = new javax.swing.JLabel();
        scoreCombo = new javax.swing.JComboBox();
        strandLabel = new javax.swing.JLabel();
        strandCombo = new javax.swing.JComboBox();
        thickStartLabel = new javax.swing.JLabel();
        thickStartCombo = new javax.swing.JComboBox();
        thickEndLabel = new javax.swing.JLabel();
        thickEndCombo = new javax.swing.JComboBox();
        itemRGBLabel = new javax.swing.JLabel();
        itemRGBCombo = new javax.swing.JComboBox();
        blockStartsLabel = new javax.swing.JLabel();
        blockStartsCombo = new javax.swing.JComboBox();
        blockEndsLabel = new javax.swing.JLabel();
        blockEndsCombo = new javax.swing.JComboBox();
        jPanel1 = new javax.swing.JPanel();
        treatAsAbsoluteCheck = new javax.swing.JCheckBox();
        treatAsSizeCheck = new javax.swing.JCheckBox();
        byChromosomeCheck = new javax.swing.JCheckBox();
        name2Label = new javax.swing.JLabel();
        name2Combo = new javax.swing.JComboBox();

        setBorder(javax.swing.BorderFactory.createTitledBorder("Field Mappings"));
        setMinimumSize(new java.awt.Dimension(400, 412));
        setPreferredSize(new java.awt.Dimension(400, 412));
        setLayout(new java.awt.GridBagLayout());

        chromLabel.setText("Chromosome:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(chromLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(chromCombo, gridBagConstraints);

        startLabel.setText("Start:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(startLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(startCombo, gridBagConstraints);

        endLabel.setText("End:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(endLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(endCombo, gridBagConstraints);

        nameLabel.setText("Name:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(nameLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        add(nameCombo, gridBagConstraints);

        scoreLabel.setText("Score:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(scoreLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(scoreCombo, gridBagConstraints);

        strandLabel.setText("Strand:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(strandLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(strandCombo, gridBagConstraints);

        thickStartLabel.setText("Thick Start:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(thickStartLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(thickStartCombo, gridBagConstraints);

        thickEndLabel.setText("Thick End:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(thickEndLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(thickEndCombo, gridBagConstraints);

        itemRGBLabel.setText("Item RGB:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(itemRGBLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(itemRGBCombo, gridBagConstraints);

        blockStartsLabel.setText("Block Starts:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(blockStartsLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(blockStartsCombo, gridBagConstraints);

        blockEndsLabel.setText("Block Ends:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(blockEndsLabel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(blockEndsCombo, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.weighty = 1.0;
        add(jPanel1, gridBagConstraints);

        treatAsAbsoluteCheck.setText("Treat as absolute");
        treatAsAbsoluteCheck.setToolTipText("Select if block-starts are stored as absolute offsets within the chromosome.\nLeave unchecked if block-starts are relative to the start of the feature.\n");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 9;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(treatAsAbsoluteCheck, gridBagConstraints);

        treatAsSizeCheck.setText("Treat as size");
        treatAsSizeCheck.setToolTipText("Select if this column contains block sizes.\nLeave unchecked if block-ends are specified as positions.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 10;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(treatAsSizeCheck, gridBagConstraints);

        byChromosomeCheck.setText("One table per chromosome");
        byChromosomeCheck.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                byChromosomeCheckActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(byChromosomeCheck, gridBagConstraints);

        name2Label.setText("Alternate Name:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(name2Label, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        add(name2Combo, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents

    private void byChromosomeCheckActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_byChromosomeCheckActionPerformed
        chromCombo.setEnabled(!byChromosomeCheck.isSelected());
    }//GEN-LAST:event_byChromosomeCheckActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox blockEndsCombo;
    private javax.swing.JLabel blockEndsLabel;
    private javax.swing.JComboBox blockStartsCombo;
    private javax.swing.JLabel blockStartsLabel;
    private javax.swing.JCheckBox byChromosomeCheck;
    private javax.swing.JComboBox chromCombo;
    private javax.swing.JLabel chromLabel;
    private javax.swing.JComboBox endCombo;
    private javax.swing.JLabel endLabel;
    private javax.swing.JComboBox itemRGBCombo;
    private javax.swing.JLabel itemRGBLabel;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JComboBox name2Combo;
    private javax.swing.JLabel name2Label;
    private javax.swing.JComboBox nameCombo;
    private javax.swing.JLabel nameLabel;
    private javax.swing.JComboBox scoreCombo;
    private javax.swing.JLabel scoreLabel;
    private javax.swing.JComboBox startCombo;
    private javax.swing.JLabel startLabel;
    private javax.swing.JComboBox strandCombo;
    private javax.swing.JLabel strandLabel;
    private javax.swing.JComboBox thickEndCombo;
    private javax.swing.JLabel thickEndLabel;
    private javax.swing.JComboBox thickStartCombo;
    private javax.swing.JLabel thickStartLabel;
    private javax.swing.JCheckBox treatAsAbsoluteCheck;
    private javax.swing.JCheckBox treatAsSizeCheck;
    // End of variables declaration//GEN-END:variables

    public void setFormat(MappingFormat format) {
        this.format = format;
        switch (format) {
            case INTERVAL_RICH:
                chromLabel.setText("Chromosome:");
                byChromosomeCheck.setVisible(true);
                startLabel.setVisible(true);
                startCombo.setVisible(true);
                endLabel.setVisible(true);
                endCombo.setVisible(true);
                endLabel.setVisible(true);
                endCombo.setVisible(true);
                nameLabel.setText("Name:");
                nameLabel.setVisible(true);
                nameCombo.setVisible(true);
                scoreLabel.setText("Score:");
                scoreLabel.setVisible(true);
                scoreCombo.setVisible(true);
                strandLabel.setText("Strand:");
                strandLabel.setVisible(true);
                strandCombo.setVisible(true);
                thickStartLabel.setText("Thick Start:");
                thickStartLabel.setVisible(true);
                thickStartCombo.setVisible(true);
                thickEndLabel.setText("Thick End:");
                thickEndLabel.setVisible(true);
                thickEndCombo.setVisible(true);
                itemRGBLabel.setText("Item RGB:");
                itemRGBLabel.setVisible(true);
                itemRGBCombo.setVisible(true);
                blockStartsLabel.setVisible(true);
                blockStartsCombo.setVisible(true);
                treatAsAbsoluteCheck.setVisible(true);
                blockEndsLabel.setVisible(true);
                blockEndsCombo.setVisible(true);
                treatAsSizeCheck.setVisible(true);
                name2Label.setVisible(true);
                name2Combo.setVisible(true);
                break;
            case CONTINUOUS_WIG:
                chromLabel.setText("Chromosome:");
                byChromosomeCheck.setVisible(true);
                startLabel.setVisible(true);
                startCombo.setVisible(true);
                endLabel.setVisible(true);
                endCombo.setVisible(true);
                endLabel.setVisible(true);
                endCombo.setVisible(true);
                nameLabel.setText("Span:");
                nameLabel.setVisible(true);
                nameCombo.setVisible(true);
                scoreLabel.setText("Count:");
                scoreLabel.setVisible(true);
                scoreCombo.setVisible(true);
                strandLabel.setText("Offset:");
                strandLabel.setVisible(true);
                strandCombo.setVisible(true);
                thickStartLabel.setText("File:");
                thickStartLabel.setVisible(true);
                thickStartCombo.setVisible(true);
                thickEndLabel.setText("Lower Limit:");
                thickEndLabel.setVisible(true);
                thickEndCombo.setVisible(true);
                itemRGBLabel.setText("Data Range:");
                itemRGBLabel.setVisible(true);
                itemRGBCombo.setVisible(true);
                blockStartsLabel.setVisible(false);
                blockStartsCombo.setVisible(false);
                treatAsAbsoluteCheck.setVisible(false);
                blockEndsLabel.setVisible(false);
                blockEndsCombo.setVisible(false);
                treatAsSizeCheck.setVisible(false);
                name2Label.setVisible(false);
                name2Combo.setVisible(false);
                break;
            case EXTERNAL_FILE:
                chromLabel.setText("Path to File:");
                byChromosomeCheck.setVisible(false);
                startLabel.setVisible(false);
                startCombo.setVisible(false);
                endLabel.setVisible(false);
                endCombo.setVisible(false);
                nameLabel.setVisible(false);
                nameCombo.setVisible(false);
                scoreLabel.setVisible(false);
                scoreCombo.setVisible(false);
                strandLabel.setVisible(false);
                strandCombo.setVisible(false);
                thickStartLabel.setVisible(false);
                thickStartCombo.setVisible(false);
                thickEndLabel.setVisible(false);
                thickEndCombo.setVisible(false);
                itemRGBLabel.setVisible(false);
                itemRGBCombo.setVisible(false);
                blockStartsLabel.setVisible(false);
                blockStartsCombo.setVisible(false);
                treatAsAbsoluteCheck.setVisible(false);
                blockEndsLabel.setVisible(false);
                blockEndsCombo.setVisible(false);
                treatAsSizeCheck.setVisible(false);
                name2Label.setVisible(false);
                name2Combo.setVisible(false);
                break;
            default:
                nameLabel.setText(format == MappingFormat.CONTINUOUS_VALUE_COLUMN ? "Value:" : "Name:");
                byChromosomeCheck.setVisible(true);
                startLabel.setVisible(true);
                startCombo.setVisible(true);
                endLabel.setVisible(true);
                endCombo.setVisible(true);
                endLabel.setVisible(true);
                endCombo.setVisible(true);
                scoreLabel.setVisible(false);
                scoreCombo.setVisible(false);
                strandLabel.setVisible(false);
                strandCombo.setVisible(false);
                thickStartLabel.setVisible(false);
                thickStartCombo.setVisible(false);
                thickEndLabel.setVisible(false);
                thickEndCombo.setVisible(false);
                itemRGBLabel.setVisible(false);
                itemRGBCombo.setVisible(false);
                blockStartsLabel.setVisible(false);
                blockStartsCombo.setVisible(false);
                treatAsAbsoluteCheck.setVisible(false);
                blockEndsLabel.setVisible(false);
                blockEndsCombo.setVisible(false);
                treatAsSizeCheck.setVisible(false);
                name2Label.setVisible(false);
                name2Combo.setVisible(false);
                break;
        }
    }

    public void populate(Column[] columns, ColumnMapping mapping, boolean byChromosome) {
        if (!byChromosome) {
            populateFieldCombo(chromCombo, columns, Types.CHAR, mapping.chrom);
        }
        byChromosomeCheck.setSelected(byChromosome);
        chromCombo.setEnabled(!byChromosome);
        populateFieldCombo(startCombo, columns, Types.INTEGER, mapping.start);
        populateFieldCombo(endCombo, columns, Types.INTEGER, mapping.end);
        switch (format) {
            case CONTINUOUS_VALUE_COLUMN:
                populateFieldCombo(valueCombo, columns, Types.REAL, mapping.value);
                break;
            case INTERVAL_GENERIC:
                populateFieldCombo(nameCombo, columns, Types.CHAR, mapping.name);
                break;
            case INTERVAL_RICH:
                populateFieldCombo(nameCombo, columns, Types.CHAR, mapping.name);
                populateFieldCombo(scoreCombo, columns, Types.REAL, mapping.score);
                populateFieldCombo(strandCombo, columns, Types.CHAR, mapping.strand);
                populateFieldCombo(thickStartCombo, columns, Types.INTEGER, mapping.thickStart);
                populateFieldCombo(thickEndCombo, columns, Types.INTEGER, mapping.thickEnd);
                populateFieldCombo(itemRGBCombo, columns, Types.INTEGER, mapping.itemRGB);
                if (mapping.blockStartsAbsolute != null) {
                    treatAsAbsoluteCheck.setSelected(true);
                    populateFieldCombo(blockStartsCombo, columns, Types.BLOB,  mapping.blockStartsAbsolute);
                } else {
                    treatAsAbsoluteCheck.setSelected(false);
                    populateFieldCombo(blockStartsCombo, columns, Types.BLOB,  mapping.blockStartsRelative);
                }
                if (mapping.blockSizes != null) {
                    treatAsSizeCheck.setSelected(true);
                    populateFieldCombo(blockEndsCombo, columns, Types.BLOB, mapping.blockSizes);
                } else {
                    treatAsSizeCheck.setSelected(false);
                    populateFieldCombo(blockEndsCombo, columns, Types.BLOB, mapping.blockEnds);
                }
                populateFieldCombo(name2Combo, columns, Types.CHAR, mapping.name2);
                break;
            case CONTINUOUS_WIG:
                populateFieldCombo(spanCombo, columns, Types.INTEGER, mapping.span);
                populateFieldCombo(countCombo, columns, Types.INTEGER, mapping.count);
                populateFieldCombo(offsetCombo, columns, Types.INTEGER, mapping.offset);
                populateFieldCombo(fileCombo, columns, Types.CHAR, mapping.file);
                populateFieldCombo(lowerLimitCombo, columns, Types.REAL, mapping.lowerLimit);
                populateFieldCombo(dataRangeCombo, columns, Types.REAL, mapping.dataRange);
                break;
            case EXTERNAL_FILE:
                populateFieldCombo(pathCombo, columns, Types.CHAR, mapping.file);
                break;
        }
    }

    /**
     * Populate the field combo columns of the appropriate type.
     *
     * @param combo combo-box to be populated
     * @param columns array of column definitions from the table
     * @param desiredType one of Types.CHAR, Types.INTEGER, Types.REAL, or Types.BLOB to indicate the general type of data desired
     * @param mappedName name of column we think this combo should be mapped to
     */
    private void populateFieldCombo(JComboBox combo, Column[] columns, int desiredType, String mappedName) {
        combo.removeAllItems();

        // If we have mappings defined for this field, use it to determine the selected item.
        Column mappedCol = null;

        // Some columns allow the user to leave the column unused.
        if (combo != chromCombo && chromCombo != startCombo && chromCombo != endCombo) {
            combo.addItem(NO_COLUMN);
        }

        for (Column c : columns) {
            boolean include = false;
            switch (c.type) {
                case Types.CHAR:
                case Types.LONGNVARCHAR:
                case Types.NCHAR:
                case Types.NVARCHAR:
                case Types.VARCHAR:
                    include = desiredType == Types.CHAR;
                    break;
                case Types.BIGINT:
                case Types.INTEGER:
                case Types.SMALLINT:
                case Types.TINYINT:
                    include = desiredType == Types.INTEGER || desiredType == Types.REAL;
                    break;
                case Types.DECIMAL:
                case Types.DOUBLE:
                case Types.FLOAT:
                case Types.NUMERIC:
                case Types.REAL:
                    include = desiredType == Types.REAL;
                    break;
                case Types.BINARY:
                case Types.BLOB:
                case Types.LONGVARBINARY:
                case Types.VARBINARY:
                    include = desiredType == Types.BLOB;
                    break;
            }
            if (include) {
                combo.addItem(c);
                if (c.name.equals(mappedName)) {
                    mappedCol = c;
                }
            }
        }
        if (mappedCol != null) {
            combo.setSelectedItem(mappedCol);
        }
    }

    public ColumnMapping getMapping() {
        String chrom = null;
        if (!byChromosomeCheck.isSelected()) {
            chrom = chromCombo.getSelectedItem().toString();
        }
        switch (format) {
            case CONTINUOUS_VALUE_COLUMN:
                return ColumnMapping.getContinuousMapping(chrom,
                        startCombo.getSelectedItem().toString(),
                        endCombo.getSelectedItem().toString(),
                        valueCombo.getSelectedItem().toString());
            case INTERVAL_GENERIC:
                return ColumnMapping.getIntervalMapping(chrom,
                        startCombo.getSelectedItem().toString(),
                        endCombo.getSelectedItem().toString(),
                        nameCombo.getSelectedItem().toString());
            case INTERVAL_RICH:
                String relativeStarts = blockStartsCombo.getSelectedItem().toString();
                String absoluteStarts = null;
                if (treatAsAbsoluteCheck.isSelected()) {
                    absoluteStarts = relativeStarts;
                    relativeStarts = null;
                }
                String ends = blockEndsCombo.getSelectedItem().toString();
                String sizes = null;
                if (treatAsSizeCheck.isSelected()) {
                    sizes = ends;
                    ends = null;
                }
                return ColumnMapping.getRichIntervalMapping(chrom,
                                                   startCombo.getSelectedItem().toString(),
                                                   endCombo.getSelectedItem().toString(),
                                                   nameCombo.getSelectedItem().toString(),
                                                   scoreCombo.getSelectedItem().toString(),
                                                   strandCombo.getSelectedItem().toString(),
                                                   thickStartCombo.getSelectedItem().toString(),
                                                   thickEndCombo.getSelectedItem().toString(),
                                                   itemRGBCombo.getSelectedItem().toString(),
                                                   relativeStarts, absoluteStarts,
                                                   ends, sizes,
                                                   name2Combo.getSelectedItem().toString());
            case CONTINUOUS_WIG:
                return ColumnMapping.getWigMapping(chrom,
                                                   startCombo.getSelectedItem().toString(),
                                                   endCombo.getSelectedItem().toString(),
                                                   spanCombo.getSelectedItem().toString(),
                                                   countCombo.getSelectedItem().toString(),
                                                   offsetCombo.getSelectedItem().toString(),
                                                   fileCombo.getSelectedItem().toString(),
                                                   lowerLimitCombo.getSelectedItem().toString(),
                                                   dataRangeCombo.getSelectedItem().toString());
            case EXTERNAL_FILE:
                return ColumnMapping.getExternalFileMapping(pathCombo.getSelectedItem().toString());
            default:
                return null;
        }
    }
}
